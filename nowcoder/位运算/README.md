#一些常用的考查位运算的例子


## single number 问题 
整型数组中只有一个整数只出现了一次，其他整数都出现了两次，找出出现一次的这个整数，并返回。 
异或运算 
利用异或运算整型数自身与自身异或为0的特点。
```
int singleNum(int[] arr){
    int res = arr[0];
    for(int i=1;i<arr.length;i++){
        res=res^arr[i];
    }
    return res;
}
```

## 题目二：一个十进制数的二进制形式中1的个数 
与运算 
利用与运算0&1=0，不断将一个非零数不断将二进制形式中的1置于0
```
int get_one_num(int n){
    int res = 0;
    while(n){
       n = n&(n-1);
       res++;
    }
    return res;
}
```

## 判断一个数是否为2的幂
判断一个数是否为2的幂，比如1=2^0,2=2^1,4=2^2 
与运算 
利用与运算中，2&1=0，4&3=0，利用2的幂-1与2的幂的与运算结果为0，2的幂的二进制形式一定只有一位为1，其他为0，而他的减一形式一定是这一位为0，其他为1.
```
boolean istwores(int n){
     return n&(n-1)==0?True:False;
}
```

##题目四 判断一个数是否为4的幂
题目四 判断一个数是否为4的幂，4^0=1,4^1=4,4^2=16 
4^n=2^(2n) 
```
boolean isfourres(int n){
       return n&&(n-1)==0&&n&(0x55555555)？True:False;
}
```
> 也可以通过两次判断是否是2个幂

> 4的幂有些特点，只可能在特殊的位置上出现1.其他位置为0。 因此 0x55555555就是起这个作用。不过要先排除 2n的可能


## 输入两个整数m和n，计算需要改变多少位能使m变成n
```
int fun(int m, int n)
{
    //将m和n按位异或，相同的位为0，不同的位为1
    m = m ^ n;
    int count = 0;
    //统计不同的位有多少个就ok
    while(m)
    {
        m = m & (m - 1);
        ++count;
    }
    return count；
}

```
> 先计算有多少不同的位。然后再统计不同位置1的个数

## n & (~n + 1)提取出整数n最后一位为1的数 

举例：n = 01101，~n是将n按位取反就是10010，~n + 1 = 10011，最后，n & (~n + 1) = 00001

题：统计一个整数中二进制位上1的个数。

## 获取一个正整数最后一位的值

```
last = n & 1;
```